#!/usr/bin/env python3

"""
JSON-to-Go
by Matt Holt
https://github.com/mholt/json-to-go

A simple utility to translate JSON into a Go type definition.

Python translation by Gemini.
"""

import json
import re
import uuid
import math
import random
import sys
from typing import List, Dict, Any, Optional, Set


class JsonToGo:
    """
    Converts a JSON string into a Go type definition.
    """

    # https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810
    COMMON_INITIALISMS = [
        "ACL",
        "API",
        "ASCII",
        "CPU",
        "CSS",
        "DNS",
        "EOF",
        "GUID",
        "HTML",
        "HTTP",
        "HTTPS",
        "ID",
        "IP",
        "JSON",
        "LHS",
        "QPS",
        "RAM",
        "RHS",
        "RPC",
        "SLA",
        "SMTP",
        "SQL",
        "SSH",
        "TCP",
        "TLS",
        "TTL",
        "UDP",
        "UI",
        "UID",
        "UUID",
        "URI",
        "URL",
        "UTF8",
        "VM",
        "XML",
        "XMPP",
        "XSRF",
        "XSS",
    ]

    # Compile regexes once for efficiency
    RE_TIME = re.compile(r"^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$")
    RE_UUID = re.compile(
        r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
        re.I,
    )
    RE_JSON_FLOAT_HACK = re.compile(r"(:\s*\[?\s*-?\d*)\.0")
    RE_SANITIZER = re.compile(r"[^a-zA-Z0-9]")
    RE_SCREAMING_SNAKE = re.compile(r"^[_A-Z0-9]+$")
    RE_PROPER_CASE_1 = re.compile(r"(^|[^a-zA-Z])([a-z]+)")
    RE_PROPER_CASE_2 = re.compile(r"([A-Z])([a-z]+)")
    RE_NUMERIC_STRING = re.compile(r"^\d+$")

    def __init__(
        self,
        typename: str = "AutoGenerated",
        flatten: bool = True,
        example: bool = False,
        all_omitempty: bool = False,
    ):
        self.go: str = ""
        self.accumulator: str = ""
        self.stack: List[str] = []
        self.seen: Dict[str, Set[str]] = {}
        self.parent: str = ""
        self.globally_seen_type_names: Set[str] = set()
        self.previous_parents: str = ""
        self.tabs: int = 0
        self.inner_tabs: int = 0

        self.typename: str = self._format(typename or "AutoGenerated")
        self.flatten: bool = flatten
        self.example: bool = example
        self.all_omitempty: bool = all_omitempty

    def convert(self, json_string: str) -> Dict[str, str]:
        """
        Converts the provided JSON string into a Go type definition.
        Returns a dictionary with 'go' or 'error' key.
        """
        try:
            # Hack to force floats to remain floats (e.g. 1.0 -> 1.1)
            json_string = self.RE_JSON_FLOAT_HACK.sub(r"\1.1", json_string)
            data = json.loads(json_string)
            scope = data
        except Exception as e:
            return {"go": "", "error": str(e)}

        self._append(f"type {self.typename} ")
        self._parse_scope(scope)

        if self.flatten:
            self.go += self.accumulator

        # Add final newline for POSIX 3.206
        if not self.go.endswith("\n"):
            self.go += "\n"

        return {"go": self.go}

    def _parse_scope(self, scope: Any, depth: int = 0):
        """
        Recursively parses the JSON scope (object, array, primitive).
        """
        if isinstance(scope, dict):
            # Check if this dict should be represented as a map
            if self._should_be_map(scope):
                self._parse_as_map(scope, depth)
            else:
                if self.flatten:
                    if depth >= 2:
                        self._appender(self.parent)
                    else:
                        self._append(self.parent)
                self._parse_struct(
                    depth + 1, self.inner_tabs, scope, False, self.previous_parents
                )

        elif isinstance(scope, list):
            slice_type: Optional[str] = None
            scope_length = len(scope)

            for item in scope:
                this_type = self._go_type(item)
                if slice_type is None:
                    slice_type = this_type
                elif slice_type != this_type:
                    slice_type = self._most_specific_possible_go_type(
                        this_type, slice_type
                    )
                    if slice_type == "any":
                        break

            slice_str = (
                f"[]{self.parent}"
                if self.flatten and slice_type in ["struct", "slice"]
                else "[]"
            )

            if self.flatten and depth >= 2:
                self._appender(slice_str)
            else:
                self._append(slice_str)

            if slice_type == "struct":
                all_fields: Dict[str, Dict[str, Any]] = {}
                for item in scope:
                    if not isinstance(item, dict):
                        continue
                    keys = list(item.keys())
                    for keyname in keys:
                        if keyname not in all_fields:
                            all_fields[keyname] = {"value": item[keyname], "count": 0}
                        else:
                            existing_value = all_fields[keyname]["value"]
                            current_value = item[keyname]

                            if not self._are_same_type(existing_value, current_value):
                                if existing_value is not None:
                                    all_fields[keyname]["value"] = None  # Force 'any'
                                    print(
                                        f'Warning: key "{keyname}" uses multiple types. Defaulting to type "any".',
                                        file=sys.stderr,
                                    )
                                all_fields[keyname]["count"] += 1
                                continue

                            if isinstance(current_value, (int, float)):
                                all_fields[keyname]["value"] = (
                                    self._find_best_value_for_number_type(
                                        existing_value, current_value
                                    )
                                )

                            if self._are_objects(existing_value, current_value):
                                comparison_result = self._compare_object_keys(
                                    list(current_value.keys()),
                                    list(existing_value.keys()),
                                )
                                if not comparison_result:
                                    # Handle duplicate keys with different structs
                                    keyname = f"{keyname}_{self._uuidv4()}"
                                    all_fields[keyname] = {
                                        "value": current_value,
                                        "count": 0,
                                    }
                        all_fields[keyname]["count"] += 1

                # Create a common struct with all fields
                struct: Dict[str, Any] = {}
                omitempty: Dict[str, bool] = {}
                for keyname, elem in all_fields.items():
                    struct[keyname] = elem["value"]
                    omitempty[keyname] = elem["count"] != scope_length

                self._parse_struct(
                    depth + 1, self.inner_tabs, struct, omitempty, self.previous_parents
                )

            elif slice_type == "slice":
                if scope:
                    self._parse_scope(scope[0], depth)
                else:
                    # Empty array, cannot determine type
                    if self.flatten and depth >= 2:
                        self._appender("any")
                    else:
                        self._append("any")

            else:
                item_type = slice_type or "any"
                if self.flatten and depth >= 2:
                    self._appender(item_type)
                else:
                    self._append(item_type)

        else:  # Primitive
            if self.flatten and depth >= 2:
                self._appender(self._go_type(scope))
            else:
                self._append(self._go_type(scope))

    def _parse_struct(
        self,
        depth: int,
        inner_tabs: int,
        scope: Dict[str, Any],
        omitempty: Any,
        old_parents: str,
    ):
        """
        Parses a JSON object and converts it into a Go struct.
        """
        if self.flatten:
            self.stack.append("\n" if depth >= 2 else "")

        seen_type_names: Set[str] = set()

        if self.flatten and depth >= 2:
            parent_type = f"type {self.parent}"
            scope_keys = self._format_scope_keys(list(scope.keys()))

            if self.parent in self.seen and self._compare_object_keys_set(
                scope_keys, self.seen[self.parent]
            ):
                self.stack.pop()
                return
            self.seen[self.parent] = scope_keys

            self._appender(f"{parent_type} struct {{\n")
            inner_tabs += 1
            keys = sorted(scope.keys())
            self.previous_parents = self.parent
            for key in keys:
                keyname = self._get_original_name(key)
                self._indenter(inner_tabs)

                val = scope[key]
                if isinstance(val, dict) or (
                    isinstance(val, list) and val and isinstance(val[0], dict)
                ):
                    typename = self._unique_type_name(
                        self._format(keyname),
                        self.globally_seen_type_names,
                        self.previous_parents,
                    )
                    self.globally_seen_type_names.add(typename)
                else:
                    typename = self._unique_type_name(
                        self._format(keyname), seen_type_names
                    )
                    seen_type_names.add(typename)

                self._appender(f"{typename} ")
                self.parent = typename
                self._parse_scope(val, depth)
                self._appender(f' `json:"{keyname}')
                if self.all_omitempty or (omitempty and omitempty.get(key) is True):
                    self._appender(",omitempty")
                self._appender('"`\n')

            inner_tabs -= 1
            self._indenter(inner_tabs)
            self._appender("}")
            self.previous_parents = old_parents

        else:  # Non-flatten (inline)
            self._append("struct {\n")
            self.tabs += 1
            keys = sorted(scope.keys())
            self.previous_parents = self.parent
            for key in keys:
                keyname = self._get_original_name(key)
                self._indent(self.tabs)

                val = scope[key]
                if isinstance(val, dict) or (
                    isinstance(val, list) and val and isinstance(val[0], dict)
                ):
                    typename = self._unique_type_name(
                        self._format(keyname),
                        self.globally_seen_type_names,
                        self.previous_parents,
                    )
                    self.globally_seen_type_names.add(typename)
                else:
                    typename = self._unique_type_name(
                        self._format(keyname), seen_type_names
                    )
                    seen_type_names.add(typename)

                self._append(f"{typename} ")
                self.parent = typename
                self._parse_scope(val, depth)
                self._append(f' `json:"{keyname}')
                if self.all_omitempty or (omitempty and omitempty.get(key) is True):
                    self._append(",omitempty")
                if self.example and val != "" and not isinstance(val, (dict, list)):
                    self._append(f'" example:"{val}')
                self._append('"`\n')

            self.tabs -= 1
            self._indent(self.tabs)
            self._append("}")
            self.previous_parents = old_parents

        if self.flatten:
            self.accumulator += self.stack.pop()

    def _indent(self, tabs: int):
        self.go += "\t" * tabs

    def _append(self, s: str):
        self.go += s

    def _indenter(self, tabs: int):
        if self.stack:
            self.stack[-1] += "\t" * tabs

    def _appender(self, s: str):
        if self.stack:
            self.stack[-1] += s

    def _unique_type_name(
        self, name: str, seen: Set[str], prefix: Optional[str] = None
    ) -> str:
        """
        Generates a unique field name to avoid duplicates.
        """
        if name not in seen:
            return name

        if prefix:
            prefixed_name = prefix + name
            if prefixed_name not in seen:
                return prefixed_name

        i = 0
        while True:
            new_name = f"{name}{i}"
            if new_name not in seen:
                return new_name
            i += 1

    def _format(self, s: str) -> str:
        """
        Sanitizes and formats a string to make it an appropriate Go identifier.
        """
        s = self._format_number(s)
        sanitized = self.RE_SANITIZER.sub("", self._to_proper_case(s))
        if not sanitized:
            return "NAMING_FAILED"
        return self._format_number(sanitized)

    def _format_number(self, s: str) -> str:
        """
        Adds a prefix to a number to make it a Go identifier.
        """
        if not s:
            return ""
        if s.isdigit():
            return f"Num{s}"
        if s[0].isdigit():
            numbers = {
                "0": "Zero_",
                "1": "One_",
                "2": "Two_",
                "3": "Three_",
                "4": "Four_",
                "5": "Five_",
                "6": "Six_",
                "7": "Seven_",
                "8": "Eight_",
                "9": "Nine_",
            }
            return numbers[s[0]] + s[1:]
        return s

    def _go_type(self, val: Any) -> str:
        """
        Determines the most appropriate Go type for a Python value.
        """
        if val is None:
            return "any"

        if isinstance(val, str):
            if self.RE_TIME.match(val):
                return "time.Time"
            return "string"

        if isinstance(val, bool):
            return "bool"

        if isinstance(val, float):
            return "float64"

        if isinstance(val, int):
            if -2147483648 < val < 2147483647:
                return "int"
            return "int64"

        if isinstance(val, list):
            return "slice"
        if isinstance(val, dict):
            return "struct"

        return "any"

    def _find_best_value_for_number_type(
        self, existing_value: Any, new_value: Any
    ) -> Any:
        """
        Updates the numeric type to the largest equivalent (e.g. int -> float64).
        """
        if not isinstance(new_value, (int, float)):
            print(f"Error: currentValue {new_value} is not a number", file=sys.stderr)
            return None  # Ricade su 'any'

        new_go_type = self._go_type(new_value)
        existing_go_type = self._go_type(existing_value)

        if new_go_type == existing_go_type:
            return existing_value

        if new_go_type == "float64":
            return new_value
        if existing_go_type == "float64":
            return existing_value

        # Force update to float64 if there's a mix
        if "float" in new_go_type and "int" in existing_go_type:
            return 1.1  # A value that _go_type will see as float64
        if "int" in new_go_type and "float" in existing_go_type:
            return 1.1  # A value that _go_type will see as float64

        if "int" in new_go_type and "int" in existing_go_type:
            try:
                # Try to sum to see if it's safe
                total = abs(existing_value) + abs(new_value)
                if not math.isfinite(total):
                    return 9223372036854775807  # Max int64
                return total
            except OverflowError:
                return 9223372036854775807  # Max int64

        print(
            f"Error: something went wrong with _find_best_value_for_number_type() using values: '{new_value}' and '{existing_value}'",
            file=sys.stderr,
        )
        return None  # Falls back to 'any'

    def _most_specific_possible_go_type(self, typ1: str, typ2: str) -> str:
        """
        Given two types, returns the most specific (preferring float over int).
        """
        if typ1.startswith("float") and typ2.startswith("int"):
            return typ1
        if typ1.startswith("int") and typ2.startswith("float"):
            return typ2
        return "any"

    def _to_proper_case(self, s: str) -> str:
        """
        Converts a string to ProperCase according to Go conventions.
        """
        if self.RE_SCREAMING_SNAKE.match(s):
            s = s.lower()

        def callback1(match):
            sep = match.group(1)
            frag = match.group(2)
            if frag.upper() in self.COMMON_INITIALISMS:
                return sep + frag.upper()
            return sep + frag[0].upper() + frag[1:].lower()

        s = self.RE_PROPER_CASE_1.sub(callback1, s)

        def callback2(match):
            sep = match.group(1)
            frag = match.group(2)
            if (sep + frag).upper() in self.COMMON_INITIALISMS:
                return (sep + frag).upper()
            return sep + frag

        s = self.RE_PROPER_CASE_2.sub(callback2, s)
        return s

    def _uuidv4(self) -> str:
        """Generates a UUID v4."""
        return str(uuid.uuid4())

    def _get_original_name(self, unique: str) -> str:
        """
        Removes the UUID added to key names to make them unique.
        """
        if len(unique) >= 36:
            tail = unique[-36:]
            if self.RE_UUID.match(tail):
                return unique[:-37]  # Removes _ and UUID
        return unique

    def _are_objects(self, a: Any, b: Any) -> bool:
        """Checks if both are Python dictionaries."""
        return isinstance(a, dict) and isinstance(b, dict)

    def _are_same_type(self, a: Any, b: Any) -> bool:
        """Checks if two values have the same Python type."""
        return type(a) == type(b)

    def _compare_object_keys(self, a_keys: List[str], b_keys: List[str]) -> bool:
        """
        Checks if two lists of keys contain the same elements.
        """
        return set(a_keys) == set(b_keys)

    def _compare_object_keys_set(
        self, a_keys_set: Set[str], b_keys_set: Set[str]
    ) -> bool:
        """
        Checks if two sets of keys are identical. (Optimized version)
        """
        return a_keys_set == b_keys_set

    def _format_scope_keys(self, keys: List[str]) -> Set[str]:
        """Runs _format on a list of keys and returns a set."""
        return {self._format(k) for k in keys}
    
    def _all_keys_are_numeric_strings(self, keys: List[str]) -> bool:
        """
        Checks if all keys in the list are numeric strings (e.g., "1", "2", "100").
        """
        if not keys:
            return False
        return all(self.RE_NUMERIC_STRING.match(k) for k in keys)
    
    def _should_be_map(self, scope: Dict[str, Any]) -> bool:
        """
        Determines if a JSON object should be represented as a map[string]ValueType
        instead of a struct. This happens when:
        1. All keys are numeric strings
        2. All values have the same type
        """
        if not scope:
            return False
        
        keys = list(scope.keys())
        
        # Check if all keys are numeric strings
        if not self._all_keys_are_numeric_strings(keys):
            return False
        
        # Check if all values have the same type
        values = list(scope.values())
        if not values:
            return False
        
        first_go_type = self._go_type(values[0])
        
        # For struct and slice types, we need more detailed comparison
        if first_go_type == "struct":
            # All values should be dicts with the same keys
            if not all(isinstance(v, dict) for v in values):
                return False
            first_keys = set(values[0].keys()) if isinstance(values[0], dict) else set()
            return all(isinstance(v, dict) and set(v.keys()) == first_keys for v in values)
        
        # For other types, just check if all have the same Go type
        return all(self._go_type(v) == first_go_type for v in values)
    
    def _parse_as_map(self, scope: Dict[str, Any], depth: int = 0):
        """
        Parses a JSON object as a Go map instead of a struct.
        """
        if not scope:
            if self.flatten and depth >= 2:
                self._appender("map[string]any")
            else:
                self._append("map[string]any")
            return
        
        # Get the value type from the first value
        first_value = next(iter(scope.values()))
        value_go_type = self._go_type(first_value)
        
        # For struct types, we need to define the struct inline
        if value_go_type == "struct":
            if self.flatten and depth >= 2:
                self._appender("map[string]")
            else:
                self._append("map[string]")
            
            # Parse the struct inline (without prepending parent name)
            self._parse_struct(
                depth + 1, self.inner_tabs, first_value, False, self.previous_parents
            )
        elif value_go_type == "slice":
            # For slice types, we need to determine the element type
            if self.flatten and depth >= 2:
                self._appender("map[string]")
            else:
                self._append("map[string]")
            
            # Parse the slice type
            self._parse_scope(first_value, depth)
        else:
            # For primitive types, just use the type directly
            if self.flatten and depth >= 2:
                self._appender(f"map[string]{value_go_type}")
            else:
                self._append(f"map[string]{value_go_type}")
